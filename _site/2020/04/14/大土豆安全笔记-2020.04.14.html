<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>大土豆安全笔记 2020.04.14 | wnagzihxa1n’s blog</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="大土豆安全笔记 2020.04.14" />
<meta name="author" content="wnagzihxa1n" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="发现一个好项目，可能之前我看过但是没仔细学习，最近可以算是真正开始认真分析了 https://github.com/jiayy/android_vuln_poc-exp" />
<meta property="og:description" content="发现一个好项目，可能之前我看过但是没仔细学习，最近可以算是真正开始认真分析了 https://github.com/jiayy/android_vuln_poc-exp" />
<link rel="canonical" href="http://localhost:4000/2020/04/14/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2020.04.14.html" />
<meta property="og:url" content="http://localhost:4000/2020/04/14/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2020.04.14.html" />
<meta property="og:site_name" content="wnagzihxa1n’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-14T20:40:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="大土豆安全笔记 2020.04.14" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"wnagzihxa1n"},"@type":"BlogPosting","description":"发现一个好项目，可能之前我看过但是没仔细学习，最近可以算是真正开始认真分析了 https://github.com/jiayy/android_vuln_poc-exp","url":"http://localhost:4000/2020/04/14/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2020.04.14.html","headline":"大土豆安全笔记 2020.04.14","dateModified":"2020-04-14T20:40:00+08:00","datePublished":"2020-04-14T20:40:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/04/14/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2020.04.14.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
  <link rel="icon" type="image/png" href="/assets/favicon.png" /><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="wnagzihxa1n's blog" /></head>
<body><div class="site-header">
  <div class="wrapper">
    <a class="site-title" rel="author" href="/">wnagzihxa1n&#39;s blog<b class="command_prompt"></b><b class="blinking_cursor">_</b></a>
    <span class="social_links">
        <a class="color-cyan-hover" href="https://twitter.com/wnagzihxa1n"><i class="fab fa-twitter-square"></i></a><a class="color-purple-hover" href="https://github.com/wnagzihxa1n"><i class="fab fa-github-square"></i></a>
    </span>
  </div>
</div>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        
  <div class="author-box">
    
    <img src="/assets/HeadIcon.jpg" class="author-avatar" alt="Avatar" />
I am wnagzihxa1n, an unknown iOS/Android security researcher, this blog is my security study notes, just share something interesting.

</div>


<div class="post">
  <h1 class="post-title">大土豆安全笔记 2020.04.14</h1>
  
  <div class="post-tags">
      
      <a class="tag" href="/tag/security_daily/">security_daily</a>
      
  </div>
  
  <div class="post-date">Published on 14 Apr 2020</div>
  
  <p>发现一个好项目，可能之前我看过但是没仔细学习，最近可以算是真正开始认真分析了</p>
<ul>
  <li>https://github.com/jiayy/android_vuln_poc-exp</li>
</ul>

<p>冰刃实验室写的《高通加解密引擎提权漏洞解析》，写的相当好，又学习到了很多</p>
<ul>
  <li>https://www.iceswordlab.com/2017/08/07/qualcomm-crypto-engine-vulnerabilities-exploits/</li>
</ul>

<p>我这里分析的是其中的CVE-2016-6738，高通加解密驱动模块内核任意地址写漏洞，补丁如下</p>
<ul>
  <li>https://source.codeaurora.org/quic/la//kernel/msm-3.18/commit/?id=0a2528569b035a2ca8ebe9a4612dbbaaaffa5b2e</li>
</ul>

<p>注册的驱动结构体</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static struct platform_driver qcedev_plat_driver = {
	.probe = qcedev_probe,
	.remove = qcedev_remove,
	.suspend = qcedev_suspend,
	.resume = qcedev_resume,
	.driver = {
		.name = "qce",
		.owner = THIS_MODULE,
		.of_match_table = qcedev_match,
	},
};
</code></pre></div></div>

<p>所以我们打开驱动的代码如下</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int fd = open("/dev/qce", O_RDONLY);
</code></pre></div></div>

<p>根据文档描述，我们可以通过IOCTL进行调用</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The following IOCTLS are available to the user space application(s)-

  Cipher IOCTLs:
  --------------
    QCEDEV_IOCTL_ENC_REQ is for encrypting data.
    QCEDEV_IOCTL_DEC_REQ is for decrypting data.
</code></pre></div></div>

<p>该驱动对应的<code class="language-plaintext highlighter-rouge">file_operations</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int qcedev_open(struct inode *inode, struct file *file);
static int qcedev_release(struct inode *inode, struct file *file);

static const struct file_operations qcedev_fops = {
	.owner = THIS_MODULE,
	.unlocked_ioctl = qcedev_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = compat_qcedev_ioctl,
#endif
	.open = qcedev_open,
	.release = qcedev_release,
};
</code></pre></div></div>

<p>找到函数<code class="language-plaintext highlighter-rouge">qcedev_ioctl()</code>对应的实现</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>long qcedev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
{
    int err = 0;
	struct qcedev_handle *handle;
	struct qcedev_control *podev;
	struct qcedev_async_req qcedev_areq;
	struct qcedev_stat *pstat;
	
    ...
    
	switch (cmd) {
	// 通过 IOCTL 进行加解密功能的请求
	case QCEDEV_IOCTL_ENC_REQ:
	case QCEDEV_IOCTL_DEC_REQ:
	    // 用户态地址检查
		if (!access_ok(VERIFY_WRITE, (void __user *)arg, sizeof(struct qcedev_cipher_op_req)))
			return -EFAULT;

        // 通过地址检查后进行拷贝操作
        // 用户可控：qcedev_areq-&gt;cipher_op_req
		if (__copy_from_user(&amp;qcedev_areq.cipher_op_req, (void __user *)arg, sizeof(struct qcedev_cipher_op_req)))
			return -EFAULT;
		qcedev_areq.op_type = QCEDEV_CRYPTO_OPER_CIPHER;

        // 参数检查，非常多的判断
		if (qcedev_check_cipher_params(&amp;qcedev_areq.cipher_op_req, podev))
			return -EINVAL;

        // 执行加解密逻辑
		err = qcedev_vbuf_ablk_cipher(&amp;qcedev_areq, handle);
		if (err)
			return err;
			
		// 加解密成功，将数据写入用户态空间
		if (__copy_to_user((void __user *)arg, &amp;qcedev_areq.cipher_op_req, sizeof(struct qcedev_cipher_op_req)))
			return -EFAULT;
		break;
	
    ...
    
	default:
		return -ENOTTY;
	}

	return err;
}
EXPORT_SYMBOL(qcedev_ioctl);
</code></pre></div></div>

<p>结构体<code class="language-plaintext highlighter-rouge">qcedev_cipher_op_req</code>的实现</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct	qcedev_cipher_op_req {
	uint8_t				use_pmem;
	union {
		struct qcedev_pmem_info	pmem;
		struct qcedev_vbuf_info	vbuf;
	};
	uint32_t			entries;
	uint32_t			data_len;
	uint8_t				in_place_op;
	uint8_t				enckey[QCEDEV_MAX_KEY_SIZE];
	uint32_t			encklen;
	uint8_t				iv[QCEDEV_MAX_IV_SIZE];
	uint32_t			ivlen;
	uint32_t			byteoffset;
	enum qcedev_cipher_alg_enum	alg;
	enum qcedev_cipher_mode_enum	mode;
	enum qcedev_oper_enum		op;
};
</code></pre></div></div>

<p>问题出在函数<code class="language-plaintext highlighter-rouge">qcedev_vbuf_ablk_cipher()</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int qcedev_vbuf_ablk_cipher(struct qcedev_async_req *areq, struct qcedev_handle *handle)
{
	int err = 0;
	int di = 0;
	int i = 0;
	int j = 0;
	int k = 0;
	uint32_t byteoffset = 0;
	int num_entries = 0;
	uint32_t total = 0;
	uint32_t len;
	uint8_t *k_buf_src = NULL;
	uint8_t *k_align_src = NULL;
	uint32_t max_data_xfer;
	struct qcedev_cipher_op_req *saved_req;
	struct	qcedev_cipher_op_req *creq = &amp;areq-&gt;cipher_op_req;

	/* Verify Source Address's */
	// 进行用户态地址检查
	// 变量 vbuf 表示待处理的数据
	// 用户可控：areq-&gt;cipher_op_req.entries
	for (i = 0; i &lt; areq-&gt;cipher_op_req.entries; i++)
		if (!access_ok(VERIFY_READ, (void __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr, areq-&gt;cipher_op_req.vbuf.src[i].len))
			return -EFAULT;

	/* Verify Destination Address's */
	// 进行用户态地址检查
	// 有趣的是：如果 creq-&gt;in_place_op 为1就不进入if检查
	// 更有趣的是：creq-&gt;in_place_op 用户可控
	// 也就是说：我们这里可以绕过地址检查
	if (creq-&gt;in_place_op != 1) {
	    // #define QCEDEV_MAX_BUFFERS      16
		for (i = 0, total = 0; i &lt; QCEDEV_MAX_BUFFERS; i++) {
			if ((areq-&gt;cipher_op_req.vbuf.dst[i].vaddr != 0) &amp;&amp; (total &lt; creq-&gt;data_len)) {
				if (!access_ok(VERIFY_WRITE, (void __user *)creq-&gt;vbuf.dst[i].vaddr, creq-&gt;vbuf.dst[i].len)) {
					pr_err("%s:DST WR_VERIFY err %d=0x%lx\n", __func__, i, (uintptr_t)creq-&gt;vbuf.dst[i].vaddr);
					return -EFAULT;
				}
				total += creq-&gt;vbuf.dst[i].len;
			}
		}
	} else  {
		for (i = 0, total = 0; i &lt; creq-&gt;entries; i++) {
			if (total &lt; creq-&gt;data_len) {
				if (!access_ok(VERIFY_WRITE, (void __user *)creq-&gt;vbuf.src[i].vaddr, creq-&gt;vbuf.src[i].len)) {
					pr_err("%s:SRC WR_VERIFY err %d=0x%lx\n", __func__, i, (uintptr_t)creq-&gt;vbuf.src[i].vaddr);
					return -EFAULT;
				}
				total += creq-&gt;vbuf.src[i].len;
			}
		}
	}
	total = 0;

    // 用户可控：areq-&gt;cipher_op_req.mode
    // 用户可控：areq-&gt;cipher_op_req.byteoffset
	if (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)
		byteoffset = areq-&gt;cipher_op_req.byteoffset;
	
	// #define QCE_MAX_OPER_DATA		0xFF00
	// #define CACHE_LINE_SIZE 32
	// #define GFP_KERNEL	(__GFP_WAIT | __GFP_IO | __GFP_FS)
	// 分配堆空间
	k_buf_src = kmalloc(QCE_MAX_OPER_DATA + CACHE_LINE_SIZE * 2, GFP_KERNEL);
	if (k_buf_src == NULL) {
		pr_err("%s: Can't Allocate memory: k_buf_src 0x%lx\n", __func__, (uintptr_t)k_buf_src);
		return -ENOMEM;
	}
	// 内存对齐
	k_align_src = (uint8_t *)ALIGN(((uintptr_t)k_buf_src), CACHE_LINE_SIZE);
	max_data_xfer = QCE_MAX_OPER_DATA - byteoffset;

    ...

	if (areq-&gt;cipher_op_req.data_len &gt; max_data_xfer) {
	
		...
	
	} else
		err = qcedev_vbuf_ablk_cipher_max_xfer(areq, &amp;di, handle, k_align_src);
    
    ...
}
</code></pre></div></div>

<p>函数<code class="language-plaintext highlighter-rouge">qcedev_vbuf_ablk_cipher_max_xfer()</code>会把申请的堆内存指针传入处理</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static int qcedev_vbuf_ablk_cipher_max_xfer(struct qcedev_async_req *areq,
				int *di, struct qcedev_handle *handle,
				uint8_t *k_align_src)
{
	int err = 0;
	int i = 0;
	int dst_i = *di;
	struct scatterlist sg_src;
	uint32_t byteoffset = 0;
	uint8_t *user_src = NULL;
	uint8_t *k_align_dst = k_align_src;
	struct	qcedev_cipher_op_req *creq = &amp;areq-&gt;cipher_op_req;

    // 用户可控：areq-&gt;cipher_op_req.mode
	if (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)
		byteoffset = areq-&gt;cipher_op_req.byteoffset;

    // 拷贝第一份待处理数据
	user_src = (void __user *)areq-&gt;cipher_op_req.vbuf.src[0].vaddr;
	if (user_src &amp;&amp; __copy_from_user((k_align_src + byteoffset), (void __user *)user_src, areq-&gt;cipher_op_req.vbuf.src[0].len))
		return -EFAULT;

    // 移动指针指向新的写入偏移
	k_align_src += byteoffset + areq-&gt;cipher_op_req.vbuf.src[0].len;

    // 开始循环后面的待处理数据
	for (i = 1; i &lt; areq-&gt;cipher_op_req.entries; i++) {
		user_src = (void __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr;
		if (user_src &amp;&amp; __copy_from_user(k_align_src, (void __user *)user_src, areq-&gt;cipher_op_req.vbuf.src[i].len)) {
			return -EFAULT;
		}
		k_align_src += areq-&gt;cipher_op_req.vbuf.src[i].len;
	}

	/* restore src beginning */
	// 循环拷贝待处理数据完毕
	// 恢复堆空间起始地址
	k_align_src = k_align_dst;
	areq-&gt;cipher_op_req.data_len += byteoffset;

	areq-&gt;cipher_req.creq.src = (struct scatterlist *) &amp;sg_src;
	areq-&gt;cipher_req.creq.dst = (struct scatterlist *) &amp;sg_src;

	/* In place encryption/decryption */
	sg_set_buf(areq-&gt;cipher_req.creq.src, k_align_dst, areq-&gt;cipher_op_req.data_len);
	sg_mark_end(areq-&gt;cipher_req.creq.src);

	areq-&gt;cipher_req.creq.nbytes = areq-&gt;cipher_op_req.data_len;
	areq-&gt;cipher_req.creq.info = areq-&gt;cipher_op_req.iv;
	areq-&gt;cipher_op_req.entries = 1;

    // 执行加解密操作
    // 处理完成后 k_align_dst 指向的就是处理完毕后的数据
	err = submit_req(areq, handle);

	/* copy data to destination buffer*/
	creq-&gt;data_len -= byteoffset;

    // 重点关注对 creq-&gt;vbuf.dst 处理的逻辑
	while (creq-&gt;data_len &gt; 0) {
		if (creq-&gt;vbuf.dst[dst_i].len &lt;= creq-&gt;data_len) {
		    // 当还有数据的时候，就进行拷贝，拷贝的值是经过加解密后的数据
			if (err == 0 &amp;&amp; __copy_to_user((void __user *)creq-&gt;vbuf.dst[dst_i].vaddr, (k_align_dst + byteoffset), creq-&gt;vbuf.dst[dst_i].len))
				return -EFAULT;

			k_align_dst += creq-&gt;vbuf.dst[dst_i].len + byteoffset;
			creq-&gt;data_len -= creq-&gt;vbuf.dst[dst_i].len;
			dst_i++;
		} else {
			if (err == 0 &amp;&amp; __copy_to_user((void __user *)creq-&gt;vbuf.dst[dst_i].vaddr, (k_align_dst + byteoffset), creq-&gt;data_len))
				return -EFAULT;

			k_align_dst += creq-&gt;data_len;
			creq-&gt;vbuf.dst[dst_i].len -= creq-&gt;data_len;
			creq-&gt;vbuf.dst[dst_i].vaddr += creq-&gt;data_len;
			creq-&gt;data_len = 0;
		}
	}
	*di = dst_i;

	return err;
};
</code></pre></div></div>

<p>根据定义，<code class="language-plaintext highlighter-rouge">__copy_to_user()</code>直接就是拷贝，并没有对地址进行检查操作</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define __copy_from_user(to,from,n)	(memcpy(to, (void __force *)from, n), 0)
#define __copy_to_user(to,from,n)	(memcpy((void __force *)to, from, n), 0)
</code></pre></div></div>

<p>所以这里存在一处内核空间任意地址写的漏洞</p>

<p>补丁直接去掉了对<code class="language-plaintext highlighter-rouge">creq-&gt;in_place_op != 1</code>的判断，这样就老老实实的两个地址都检查一遍</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff --git a/drivers/crypto/msm/qcedev.c b/drivers/crypto/msm/qcedev.c
index e63f061..1402d3d 100644
--- a/drivers/crypto/msm/qcedev.c
+++ b/drivers/crypto/msm/qcedev.c
@@ -1234,44 +1234,6 @@ static int qcedev_vbuf_ablk_cipher(struct qcedev_async_req *areq,
 	struct qcedev_cipher_op_req *saved_req;
 	struct	qcedev_cipher_op_req *creq = &amp;areq-&gt;cipher_op_req;
 
-	/* Verify Source Address's */
-	for (i = 0; i &lt; areq-&gt;cipher_op_req.entries; i++)
-		if (!access_ok(VERIFY_READ,
-			(void __user *)areq-&gt;cipher_op_req.vbuf.src[i].vaddr,
-					areq-&gt;cipher_op_req.vbuf.src[i].len))
-			return -EFAULT;
-
-	/* Verify Destination Address's */
-	if (creq-&gt;in_place_op != 1) {
-		for (i = 0, total = 0; i &lt; QCEDEV_MAX_BUFFERS; i++) {
-			if ((areq-&gt;cipher_op_req.vbuf.dst[i].vaddr != 0) &amp;&amp;
-						(total &lt; creq-&gt;data_len)) {
-				if (!access_ok(VERIFY_WRITE,
-					(void __user *)creq-&gt;vbuf.dst[i].vaddr,
-						creq-&gt;vbuf.dst[i].len)) {
-					pr_err("%s:DST WR_VERIFY err %d=0x%lx\n",
-						__func__, i, (uintptr_t)
-						creq-&gt;vbuf.dst[i].vaddr);
-					return -EFAULT;
-				}
-				total += creq-&gt;vbuf.dst[i].len;
-			}
-		}
-	} else  {
-		for (i = 0, total = 0; i &lt; creq-&gt;entries; i++) {
-			if (total &lt; creq-&gt;data_len) {
-				if (!access_ok(VERIFY_WRITE,
-					(void __user *)creq-&gt;vbuf.src[i].vaddr,
-						creq-&gt;vbuf.src[i].len)) {
-					pr_err("%s:SRC WR_VERIFY err %d=0x%lx\n",
-						__func__, i, (uintptr_t)
-						creq-&gt;vbuf.src[i].vaddr);
-					return -EFAULT;
-				}
-				total += creq-&gt;vbuf.src[i].len;
-			}
-		}
-	}
 	total = 0;
 
 	if (areq-&gt;cipher_op_req.mode == QCEDEV_AES_MODE_CTR)
@@ -1569,6 +1531,36 @@ static int qcedev_check_cipher_params(struct qcedev_cipher_op_req *req,
 			__func__, total, req-&gt;data_len);
 		goto error;
 	}
+	/* Verify Source Address's */
+	for (i = 0, total = 0; i &lt; req-&gt;entries; i++) {
+		if (total &lt; req-&gt;data_len) {
+			if (!access_ok(VERIFY_READ,
+				(void __user *)req-&gt;vbuf.src[i].vaddr,
+					req-&gt;vbuf.src[i].len)) {
+					pr_err("%s:SRC RD_VERIFY err %d=0x%lx\n",
+						__func__, i, (uintptr_t)
+							req-&gt;vbuf.src[i].vaddr);
+					goto error;
+			}
+			total += req-&gt;vbuf.src[i].len;
+		}
+	}
+
+	/* Verify Destination Address's */
+	for (i = 0, total = 0; i &lt; QCEDEV_MAX_BUFFERS; i++) {
+		if ((req-&gt;vbuf.dst[i].vaddr != 0) &amp;&amp;
+			(total &lt; req-&gt;data_len)) {
+			if (!access_ok(VERIFY_WRITE,
+				(void __user *)req-&gt;vbuf.dst[i].vaddr,
+					req-&gt;vbuf.dst[i].len)) {
+					pr_err("%s:DST WR_VERIFY err %d=0x%lx\n",
+						__func__, i, (uintptr_t)
+							req-&gt;vbuf.dst[i].vaddr);
+					goto error;
+			}
+			total += req-&gt;vbuf.dst[i].len;
+		}
+	}
 	return 0;
 error:
 	return -EINVAL;
</code></pre></div></div>

<p>稍微改了改计划，接下来大概每周写一个漏洞分析，其它时间多读书，多看师傅们写的文章，把知识点补上，然后学习一下Web相关的知识，纯本地安全没前途，还是要多搞搞逻辑漏洞和Web漏洞</p>

<p>So漏洞我有点想法，下个月实现一下</p>

</div>


<div class="comments">
<div id="disqus_thread"></div>
<script>
 var disqus_config = function () {
     this.page.url = 'http://localhost:4000/2020/04/14/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2020.04.14.html';
     this.page.identifier = '/2020/04/14/大土豆安全笔记 2020.04.14';
     this.page.title = '大土豆安全笔记 2020.04.14';
 };

 (function() {  // REQUIRED CONFIGURATION VARIABLE: EDIT THE SHORTNAME BELOW
     var d = document, s = d.createElement('script');

     s.src = '//wnagzihxa1n-github-io.disqus.com/embed.js';

     s.setAttribute('data-timestamp', +new Date());
     (d.head || d.body).appendChild(s);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

</div>




<div class="related">
  <h2>related posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2021/01/22/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2021.01.22.html">
            大土豆安全笔记 2021.01.22 在线求团购*OS Internals III
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2021/01/15/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2021.01.15.html">
            大土豆安全笔记 2021.01.15 您已本分
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2021/01/08/%E5%A4%A7%E5%9C%9F%E8%B1%86%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-2021.01.08.html">
            大土豆安全笔记 2021.01.08 我，零基础，学iOS macOS安全
          </a>
        </h3>
      </li>
    
  </ul>
</div>



  
  <h2>all tags</h2>
  <div class="tag-cloud"><a href="/tag/android_application_security/" class="set-1">android_application_security</a> <a href="/tag/android_ctf/" class="set-3">android_ctf</a> <a href="/tag/browser_security/" class="set-4">browser_security</a> <a href="/tag/security_daily/" class="set-5">security_daily</a></div>
  



<script>
  let i = 0;
  const text = '';
  const speed = parseInt('50');
  
  function typeWriter() {
    if (i < text.length) {
      document.getElementById('animated-post-description').innerHTML += text.charAt(i);
      i++;
      setTimeout(typeWriter, speed);
    }
  }

  document.getElementById('animated-post-description').style.display = 'initial';
  typeWriter();
</script>

      </div>
    </main><footer class="site-footer">
  <div class="wrapper">
    <div class="credits"><div class="toggleWrapper">
    <input type="checkbox" class="dn" id="theme-toggle" onclick="modeSwitcher()" checked />
    <label for="theme-toggle" class="toggle">
    <span class="toggle__handler">
      <span class="crater crater--1"></span>
      <span class="crater crater--2"></span>
      <span class="crater crater--3"></span>
    </span>
        <span class="star star--1"></span>
        <span class="star star--2"></span>
        <span class="star star--3"></span>
        <span class="star star--4"></span>
        <span class="star star--5"></span>
        <span class="star star--6"></span>
    </label>
</div>
<script type="text/javascript">
const theme = localStorage.getItem('theme');

if (theme === "light") {
    document.documentElement.setAttribute('data-theme', 'light');
} else {
    document.documentElement.setAttribute('data-theme', 'dark');
}
const userPrefers = getComputedStyle(document.documentElement).getPropertyValue('content');

function activateDarkTheme() {
    document.getElementById('theme-toggle').checked = true;
    document.documentElement.setAttribute('data-theme', 'dark');
    document.documentElement.classList.add('theme--dark');
    document.documentElement.classList.remove('theme--light');
	document.getElementById("theme-toggle").className = 'light';
	window.localStorage.setItem('theme', 'dark');
}

function activateLightTheme() {
    document.getElementById('theme-toggle').checked = false;
    document.documentElement.setAttribute('data-theme', 'light');
    document.documentElement.classList.add('theme--light');
    document.documentElement.classList.remove('theme--dark');
	document.getElementById("theme-toggle").className = 'dark';
	window.localStorage.setItem('theme', 'light');
}

if (theme === "dark") {
    activateDarkTheme();
} else if (theme === "light") {
    activateLightTheme();
} else if  (userPrefers === "light") {
    activateDarkTheme();
} else {
    activateDarkTheme();
}

function modeSwitcher() {
	let currentMode = document.documentElement.getAttribute('data-theme');
	if (currentMode === "dark") {
	    activateLightTheme();
	} else {
	    activateDarkTheme();
	}
}
</script></div>
  </div>
</footer>


<script>
      window.FontAwesomeConfig = {
        searchPseudoElements: true
      }
    </script>
  </body>

</html>
